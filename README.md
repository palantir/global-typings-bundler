## Global Typings Bundler

[![Circle CI](https://circleci.com/gh/palantir/global-typings-bundler.svg?style=svg&circle-token=7aa0422260d471482bcbc9719d609e530f32ccda)](https://circleci.com/gh/palantir/global-typings-bundler)

Bundles your TypeScript definition files, like a JS module bundler does for your source files.

**WARNING**: Very experimental/unstable, use at your own risk

__Input__: granular external module definition files as generated with `tsc --module commonjs`.

```
build/
├── exportParser.d.ts
├── importParser.d.ts
├── index.d.ts
├── tsUtils.d.ts
└── someFolder/
    └── nestedModule.d.ts
```

```ts
// exportParser.d.ts
import * as ts from "typescript";
export interface ExportData {
    ...
}
export declare function parseExport(exportDecl: ts.ExportDeclaration): ExportData[];
```

```ts
// someFolder/nestedModule.d.ts
import * as ts from "typescript";
export var someGlobalVariable: string;
```

__Output__: a flattened `.d.ts` file that matches the shape of the namespaces created by a JS bundler like webpack or browserify.

TODO

#### Motivation

As we transitioned our TypeScript libraries to ES6 module syntax and our applications to use a JS module loader,
we wanted to retain interoperability with older applications that did not use a module loader or bundler. This
is easy to do for the JS -- you simply bundle using a tool like webpack and you're ready to use the browser-global
version of the library with a package manager like Bower. However, the typings generated by the compiler are unusable
in these legacy applications because of the lack of module loader (they can't have any external module imports/exports).
So, we built this tool to bridge the gap. It allows you to author a TypeScript library in ES6 module syntax and
distribute it as a strongly typed CommonJS module on NPM as well as a strongly typed global module on Bower.

#### Caveats

The following structures are not currently supported and will cause the library to either throw an error or generate incorrect typings.

* default exports: `export default ...`
* default imports mixed with named imports: `import foo, { bar } from ...`
* wildcard re-exports: `export * from ...`
* named export statements without a from clause: `export { foo, bar as baz }`. (Note: `export { foo, bar as baz } from ...` _is_ supported.)

#### Code Structure

TODO

#### Development

```
npm run lint
npm run build
```

##### Testing

In order to test your changes:

* Add/modify test cases as necessary in `test/cases`. Each test case is its own directory
and has a file named `params.json` which supplies the parameters to pass when building the bundled typings file.
If your code changes are supposed to affect the output of the library, ensure at least one test case is affected
as well. If you're simply refactoring code, it's fine to leave the test cases as they are.
* Run `npm run build` to build the latest version of your code.
* Run `npm run test` to generate output for all test cases into the `test/output` directory.
    * If the command succeeds, your code changes didn't affect the output from any test cases.
    * If the command fails, your code changes have affected the output from at least one test case.
      Use `npm run test-diff` to see the differences or view the differences between
      `test/accepted-output` and `test/output` with your favorite editor/diff tool.
* If the output in `test/output` is what is desired, run `npm run test-accept`.
* When you commit your code changes, also commit the changes to `test/accepted-output`.


#### Distribution

Publishing to NPM:

```
npm run all
npm publish dist/
```
